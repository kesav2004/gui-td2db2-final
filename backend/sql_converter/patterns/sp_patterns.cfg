# ===========================
# Stored Procedure Head
# ===========================
SP_HEAD|REPLACE\s+PROCEDURE|CREATE OR REPLACE PROCEDURE
SP_HEAD|CREATE\s+PROCEDURE|CREATE OR REPLACE PROCEDURE
SP_HEAD|PROCEDURE\s+(\w+)\s*\(|PROCEDURE \1(
SP_HEAD|\bSQL\s+SECURITY\s+INVOKER\b\s*||

# ===========================
# Procedure BEGIN/END Handling
# ===========================
SP_BODY|BEGIN\s+TRANSACTION\s*;|-- BEGIN TRANSACTION removed; DB2 uses implicit transaction control
SP_BODY|END;\s*(?=\w|\n)|END;
SP_BODY|END;\s*$|END@
SP_BODY|END\s+PROCEDURE|END

# ===========================
# Variable Handling
# ===========================
# Keep string literals untouched
#SP_BODY|SET\s+(\w+)\s*=\s*'([^']*)';|SET \1 = '\2';
SP_BODY|:(\w+)|\1
SP_BODY|VAR\s+(\w+)\s+(\w+);|DECLARE \1 \2;
SP_BODY|DECLARE\s+(\w+)\s+(\w+\(\d+(?:,\d+)?\))\s+CHARACTER\s+SET\s+Unicode\s*;|DECLARE \1 \2;
#SP_BODY|SELECT\s+(\w+)\s+INTO\s+(\w+)\s*;|SET \2 = \1;




# ===========================
# Teradata to DB2 Error Code Mappings
# ===========================
# Syntax Errors
SP_BODY|SELECT\s+SqlState\s+INTO\s+(\w+)\s*;|SET \1 = SqlState;
SP_BODY|SQLSTATE\s*=\s*'42000'|SQLSTATE = '42601'  -- Teradata syntax error → DB2 SQL syntax error
SP_BODY|SQLCODE\s*=\s*-3706|SQLSTATE = '42601'     -- Syntax error (expected tokens)
SP_BODY|SQLCODE\s*=\s*-104|SQLSTATE = '42601'      -- General SQL syntax error

# Object Not Found Errors
SP_BODY|SQLCODE\s*=\s*-5522|SQLSTATE = '42704'     -- Table/view does not exist
SP_BODY|SQLCODE\s*=\s*-204|SQLSTATE = '42704'      -- Object does not exist (alternate)
SP_BODY|SQLCODE\s*=\s*-7547|SQLSTATE = '42884'     -- Procedure not found
SP_BODY|SQLCODE\s*=\s*-440|SQLSTATE = '42884'      -- Routine not found

# Data Integrity Errors
SP_BODY|SQLCODE\s*=\s*-2603|SQLSTATE = '23505'     -- Duplicate row error
SP_BODY|SQLCODE\s*=\s*-803|SQLSTATE = '23505'      -- Unique constraint violation
SP_BODY|SQLCODE\s*=\s*-407|SQLSTATE = '23502'      -- NULL in NOT NULL column
SP_BODY|SQLCODE\s*=\s*-433|SQLSTATE = '22001'      -- Value too long for column

# Operational Errors
SP_BODY|SQLCODE\s*=\s*-2616|SQLSTATE = '22012'     -- Division by zero
SP_BODY|SQLCODE\s*=\s*-911|SQLSTATE = '40001'      -- Deadlock or timeout
SP_BODY|SQLSTATE\s*=\s*'U0000'|SQLSTATE = '58004'  -- Teradata internal → DB2 system error

# Special Cases
SP_BODY|SQLCODE\s*=\s*100|SQLSTATE = '02000'       -- No data found (cursor)
SP_BODY|SQLCODE\s*=\s*0|SQLSTATE = '00000'         -- Success code

# Add these new patterns:
SP_BODY|IF\s+SQLCODE\s*=\s*100\s+THEN|IF done = 1 THEN  -- Alternative cursor end check
SP_BODY|IF\s+SQLSTATE\s*!=\s*'00000'\s+THEN|IF SQLCODE <> 0 THEN  -- General error check
SP_BODY|SQLCODE\s*=\s*-?\d+|SQLSTATE = '58004'  -- Unknown error mapped to system error

# Add these patterns for cursor handling:
SP_BODY|DECLARE\s+CONTINUE\s+HANDLER\s+FOR\s+NOT\s+FOUND\s+BEGIN.*?END;|DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

# Cursor Handling Patterns
#SP_BODY|DECLARE\s+CONTINUE\s+HANDLER\s+FOR\s+NOT\s+FOUND\s+SET\s+done\s*=\s*1\s*;\s*BEGIN\s*END;|DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN\n    SET done = 1;\nEND;
SP_BODY|DECLARE\s+CONTINUE\s+HANDLER\s+FOR\s+NOT\s+FOUND\s*;\s*$|DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
SP_BODY|DECLARE\s+CONTINUE\s+HANDLER\s+FOR\s+NOT\s+FOUND\s+BEGIN\s*END;|DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
SP_BODY|IF\s+SQLSTATE\s*=\s*'02000'|IF done = 1
SP_BODY|IF\s+SQLCODE\s*=\s*100|IF done = 1
SP_BODY|IF\s+NOT\s+FOUND|IF done = 1


# ===========================
# Error Handler Constructs
# ===========================
# General Handlers
SP_BODY|DECLARE\s+(CONTINUE|EXIT)\s+HANDLER\s+FOR\s+SQLERROR|DECLARE \1 HANDLER FOR SQLEXCEPTION
SP_BODY|DECLARE\s+(CONTINUE|EXIT)\s+HANDLER\s+FOR\s+ERROR|DECLARE \1 HANDLER FOR SQLEXCEPTION
SP_BODY|ON\s+ERROR\s+(CONTINUE|ABORT)|DECLARE \1 HANDLER FOR SQLEXCEPTION

# Specific Condition Handlers
SP_BODY|DECLARE\s+(CONTINUE|EXIT)\s+HANDLER\s+FOR\s+NOT\s+FOUND|DECLARE \1 HANDLER FOR NOT FOUND
SP_BODY|DECLARE\s+(CONTINUE|EXIT)\s+HANDLER\s+FOR\s+SQLWARNING|DECLARE \1 HANDLER FOR SQLWARNING
SP_BODY|DECLARE\s+(CONTINUE|EXIT)\s+HANDLER\s+FOR\s+DUPLICATE_KEY|DECLARE \1 HANDLER FOR SQLSTATE '23505'

# Error Message Handling
SP_BODY|GET\s+DIAGNOSTICS\s+EXCEPTION\s+1\s+(\w+)\s*=\s*MESSAGE_TEXT|GET DIAGNOSTICS EXCEPTION 1 \1 = MESSAGE_TEXT
SP_BODY|SQLERRM|MESSAGE_TEXT
SP_BODY|RAISE\s+EXCEPTION\s+(.*?);|SIGNAL SQLSTATE '75000' SET MESSAGE_TEXT = \1;
SP_BODY|THROW\s+EXCEPTION\s+(.*?);|SIGNAL SQLSTATE '75000' SET MESSAGE_TEXT = \1;
#SP_BODY|SIGNAL\s+SQLSTATE\s+'(\d+)'\s+SET\s+MESSAGE_TEXT\s*=\s*('?[\w\.]+'?);|SIGNAL SQLSTATE '\1' SET MESSAGE_TEXT = \2;


# Transaction Control in Handlers
SP_BODY|BEGIN\s+EXCEPTION|BEGIN
SP_BODY|EXCEPTION\s+WHEN\s+OTHERS\s+THEN|DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN
SP_BODY|COMMIT\s*;|-- COMMIT; [DB2 handles transactions differently - verify]

# ===========================
# Loop / Cursor
# ===========================
SP_BODY|DECLARE\s+(\w+)\s+CURSOR\s+FOR\s+(.*?);|DECLARE \1 CURSOR FOR \2;
SP_BODY|DECLARE\s+done\s+INT\s+DEFAULT\s+0\s*;|DECLARE done INT DEFAULT 0;
SP_BODY|DECLARE\s+CONTINUE\s+HANDLER\s+FOR\s+NOT\s+FOUND\s+SET\s+done\s+=\s+1\s*;|DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
SP_BODY|FOR\s+(\w+)\s+AS\s+(\w+)\s+CURSOR\s+FOR|DECLARE \2 CURSOR FOR; OPEN \2; FETCH \2 INTO \1;

# Cursor Status Checks
SP_BODY|IF\s+SQLCODE\s+<>\s*0\s+THEN|IF done = 1 THEN
SP_BODY|IF\s+SQLCODE\s+=\s*100\s+THEN|IF done = 1 THEN

# ===========================
# Temporary Tables
# ===========================
SP_BODY|CREATE\s+VOLATILE\s+TABLE\s+(\w+)\s+|DECLARE GLOBAL TEMPORARY TABLE SESSION.\1
SP_BODY|TEMPORARY\s+TABLE\s+(.*?)\s+ON\s+COMMIT\s+PRESERVE\s+ROWS|DECLARE GLOBAL TEMPORARY TABLE \1
SP_BODY|CREATE\s+(MULTISET\s+)?VOLATILE\s+TABLE\s+(\w+)[\s\S]*?ON\s+COMMIT\s+PRESERVE\s+ROWS;|-- TODO: Convert volatile table '\2' manually

# ===========================
# Function Rewrites
# ===========================
SP_BODY|\bSYSDATE\b|CURRENT TIMESTAMP
SP_BODY|CURRENT_DATE|CURRENT DATE
SP_BODY|CURRENT_TIMESTAMP|CURRENT TIMESTAMP
SP_BODY|ADD_MONTHS\s*\((.*?)\)|ADD_MONTHS(\1)
SP_BODY|POSITION\s*\((.*?)\s+IN\s+(.*?)\)|LOCATE(\1, \2)
SP_BODY|INDEX\s*\((.*?),\s*(.*?)\)|LOCATE(\2, \1)
SP_BODY|TRIM\s*\(BOTH\s+(.*?)\s+FROM\s+(.*?)\)|TRIM(\2)
SP_BODY|NULLIFZERO\s*\((.*?)\)|CASE WHEN \1 = 0 THEN NULL ELSE \1 END
SP_BODY|ZEROIFNULL\s*\((.*?)\)|COALESCE(\1, 0)
SP_BODY|NVL\s*\((.*?),\s*(.*?)\)|COALESCE(\1, \2)
SP_BODY|CSUM\s*\((.*?)\)|SUM(\1) OVER (ORDER BY ...)

# Date/Time functions
SP_BODY|TO_DATE\s*\((.*?),\s*'YYYY-MM-DD'\)|DATE(\1)
SP_BODY|TO_TIMESTAMP\s*\((.*?),\s*'YYYY-MM-DD HH24:MI:SS'\)|TIMESTAMP(\1)

# CAST with FORMAT to VARCHAR_FORMAT
SP_BODY|CAST\((.*?)\s+AS\s+FORMAT\s+'[Z9,.]+'\)|VARCHAR_FORMAT(\1, '999,999.99')
SP_BODY|CAST\s*\((.*?)\s+AS\s+INTEGER\)|CAST(\1 AS INT)
SP_BODY|CAST\s*\((.*?)\s+AS\s+DECIMAL\)|CAST(\1 AS DECIMAL)

# TO_CHAR to VARCHAR_FORMAT
SP_BODY|TO_CHAR\((\w+),\s*'YYYY-MM-DD'\)|VARCHAR_FORMAT(\1, 'YYYY-MM-DD')
SP_BODY|TO_CHAR\((\w+),\s*'YYYYMMDD'\)|VARCHAR_FORMAT(\1, 'YYYYMMDD')
SP_BODY|TO_CHAR\((\w+),\s*'YYYYMMDDHHMISS'\)|VARCHAR_FORMAT(\1, 'YYYYMMDDHHMISS')

# ===========================
# INTERVAL fixes
# ===========================
SP_BODY|INTERVAL\s*'(\d+)'\s+DAY| \1 DAYS
SP_BODY|INTERVAL\s*'(\d+)'\s+MONTH| \1 MONTHS
SP_BODY|INTERVAL\s*'(\d+)'\s+YEAR| \1 YEARS
SP_BODY|INTERVAL\s*'(\d+)'\s+HOUR| \1 HOURS
SP_BODY|INTERVAL\s*'(\d+)'\s+MINUTE| \1 MINUTES

# ===========================
# Date Differences
SP_BODY|DATEDIFF\s*\(\s*DAY\s*,\s*(.*?),\s*(.*?)\)|DAYS(\2) - DAYS(\1)
SP_BODY|DATEDIFF\s*\(\s*MONTH\s*,\s*(.*?),\s*(.*?)\)|(YEAR(\2)*12 + MONTH(\2)) - (YEAR(\1)*12 + MONTH(\1))
SP_BODY|DATEDIFF\s*\(\s*YEAR\s*,\s*(.*?),\s*(.*?)\)|YEAR(\2) - YEAR(\1)

# ===========================
# Random and Sampling
# ===========================
SP_BODY|RANDOM\s*\(\d*\)|RAND()
SP_BODY|SAMPLE\s+(\d+)|FETCH FIRST \1 ROWS ONLY
SP_BODY|TOP\s+(\d+)|FETCH FIRST \1 ROWS ONLY
SP_BODY|\bOREPLACE\b|REPLACE

# ===========================
# Miscellaneous
# ===========================
SP_BODY|QUALIFY\s+(.*)|-- QUALIFY removed: \1 (requires subquery rewrite)
SP_BODY|WITH\s+DATA\s+PRIMARY\s+INDEX|-- WITH DATA PRIMARY INDEX removed (DB2 uses different indexing)
SP_BODY|COLLECT\s+STATISTICS|-- COLLECT STATISTICS removed (DB2 uses RUNSTATS)
SP_BODY|MULTISET\s+TABLE|-- MULTISET TABLE removed (DB2 handles tables differently)
SP_BODY|BEGIN\s+QUERY\s+LOGGING|-- BEGIN QUERY LOGGING removed (DB2 uses different logging mechanism)
SP_BODY|END\s+QUERY\s+LOGGING|-- END QUERY LOGGING removed

# =============================================
# CONTEXT-SENSITIVE ERROR PATTERNS
# =============================================
# Cursor loops checking SQLCODE
SP_BODY|IF\s+SQLCODE\s*=\s*100\s+THEN\s+LEAVE\s+(\w+);|IF done = 1 THEN LEAVE \1;
